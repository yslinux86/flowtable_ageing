# 1 简介
## 1.1 传统方案存在的问题
流的老化传统操作为，每隔1分钟（时间根据具体要求设置）全局扫描一下存放流的哈希表，比对流的时间戳，超过1分钟的流则全部老化。这种方案存在以下几个问题：

 1、老化时间粒度比较粗糙，如某个新流在老化任务刚完成后到来，假设后续没有同样的流，则该流需要经历近2分钟才会被老化，该流后的第一次老化处理不会删除该流，第二次老化处理才会删除；
 
 2、在老化时刻，由于全局扫描所有流数据，会造成CPU异常忙碌而无法及时处理新流，从而造成丢包；
 
 3、考虑到可以将做老化任务的功能绑定到某个CPU核上，其他核处理新流数据，但在没有老化任务时，而该CPU核大部分时间是闲置的，是CPU资源的极大浪费。
## 1.2 本方案思路
为了解决以上问题，这里提出一个精细化的流老化方案。
该方案根据流到来时所在老化区间对流进行分类，并将流加入到相应区间的老化链表中，当前老化区间由老化标记位决定，老化标记位会定时更新，更新间隔可设置较小，如5秒、10秒等，老化标记更新后最旧的老化等级链表节点全部删除。本方案功能包含哈希表，流的等级表，老化标记位，流发生模拟器等。
# 2 组件介绍
## 2.1 哈希表
哈希表为一个大数组，比如一个大小为100万的数组，数组元素为双链表，考虑到可能出现两个不同的流计算出的哈希模100万后发生哈希碰撞，这时将新的流添加到已有相同哈希数组位置的链表后。该数组越大，发生哈希碰撞的可能性越低。
## 2.2 老化等级链表
老化等级链表为双链表数组，数组大小由老化等级数量确定，如可配置30个等级，每隔1秒老化一个最旧等级链表，就相当于老化时间为30秒，但时间精度为1秒。
## 2.3 老化标记位
老化标记位定时更新，如每隔1秒老化一个最旧等级链表，则每隔1秒更新该标记位。
## 2.4 新流产生模拟器
设计几个线程模拟产生流数据，并调用相应处理函数来处理新产生的流数据。
# 3 新流处理流程
## 3.1 计算哈希值
新新到来时，先计算哈希值，哈希算法可以自行确定，这里采用SM3哈希算法，取哈希值末4位数据对哈希表的大小取模，得到该流应处于哈希表的位置。
## 3.2 查找哈希表
查找该流在哈希表下标的元素，若不为空，则遍历该链表节点的所有元素，比较节点数据的五元组和新流五元组是否一致。
### 3.2.1 没有查到
哈希表中该下标为空，则直接将新流添加到该下标数据中。
### 3.2.2 存在哈希碰撞
该数组下标已存在流数据，则说明存在哈希碰撞，则将新流添加到该数组下标链表中。
### 3.2.3 存在同样流
若遍历节点后发现存在同样的流，则将该已存在的流移至当前【最新】等级链表中。
## 3.3 添加到老化等级链表
根据流数据查找结果，将添加到老化链表中，或更新再老化链表中的位置。
注：这也是区别于传统流处理流程，新增了老化等级链表，并根据老化等级进行老化，无需根据每个流的时间戳老化。
# 4 老化处理流程
## 4.1 何时发生老化
定义一个标记位，每隔一段时间对该标记位增加1，如index=0，新来的流全部添加到下标为0的老化链表中，在1秒后，index=1，这时新来的流全部添加到下标为1的老化链表中，这时index=2的老化链表中存在的数据及相应的哈希表中节点数据全部删除，以此类推。
## 4.2 老化动作
将最旧老化链表中的节点数据及相应的哈希表中节点数据全部删除。
